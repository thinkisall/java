메서드 재정의하기 == Overriding

- 상속받은 상위 클래스의 메서드를 하위클래스가 입맛대로 바꾸는 것.

[형변환을 통해서 부모클래스의 타입을 가져와 자식클래스의 인스턴스를 생성하면 생기는일]

1. 무조건 부모클래스의 메서드를 사용하게됨
   자식클래스에서 생성된 다른 메서드나 변수들은 사용못함.

but, [중요한 예외가 있음]

그게 바로 아래 내용

: 부모 클래스인 `Customer`에서 선언된 `calcPrice()` 메서드는 자식 클래스에서 오버라이딩되었습니다.

따라서 `customerKim`이라는 객체가 `VipCustomer` 클래스로 생성되었다 하더라도, `calcPrice()` 메서드는 `VipCustomer` 클래스에서 오버라이딩된 메서드가 호출되며, 그 결과로 반환되는 값은 `VipCustomer` 클래스의 `calcPrice()` 메서드에 의해 계산되는 값입니다.

그래서 `System.out.println(customerKim.calcPrice(10000));` 코드가 실행될 때, `customerKim` 객체는 `VipCustomer` 클래스로 생성되었지만, `calcPrice()` 메서드는 `VipCustomer` 클래스의 메서드가 호출되어 반환되는 값은 `VipCustomer` 클래스에서 계산된 값입니다. 이것은 오버라이딩의 개념 중 다형성의 구현으로, 자식 클래스에서 부모 클래스의 메서드를 오버라이딩하면, 부모 클래스 타입의 변수로도 자식 클래스에서 오버라이딩한 메서드를 호출할 수 있게 됩니다.

= 정리하면 오버로딩의 경우에는 형변환을 통해서 부모타입을 가진 자식클래스의 인스턴스를 생성해도

오버로딩의 경우에는 자식클래스의 메서드를 사용가능하다. => 가상메서드 뒤에서 정리함.

![그림으로보기](../img/%ED%98%95%EB%B3%80%ED%99%98%EC%97%90%EC%84%9C%EC%9D%98%20%EC%98%88%EC%99%B8.png)
